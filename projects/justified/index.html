---
layout: project
title: Justifying Lines in C++
main: projects
sub: listing
---

<div class="in-line section">
  <div class="container">
    <div class="sixteen columns">
      &nbsp;
    </div>
  </div>

  <div class="container division">
    <div class="three columns header">
      TOOLS
    </div>
    <div class="thirteen columns details">
      C++</br>
    </div>
  </div>

  <div class="container">
    <div class="sixteen columns">
      &nbsp;
    </div>
  </div>
</div>

<div class="container">
	<div class="sixteen columns">
   <p>
     <h4>Description</h4>
   </p>
   <p>
     This is a C++ command line application that reads in an inputfile and a line length, justifies the text in the input file and writes it to the outputfile.
   </p>
   <p>
     <h4>Motivation</h4>
   </p>
   <p>
    I couldn't find this code outside in the Internet, and this was required for an assignment, so I put it up here. Nothing too advanced was used, as the implementation is pretty straightforward.
   </p>
   <p>
    <h4>Code</h4>
   </p>
	 <p>
{% highlight c++ %}
#include <iostream>
#include <string>
#include <fstream>
#include <istream>
#include <cstdlib>
#include <string>

using namespace std;

class LineTools {
public:
  void justifyLines(string filenameIn, string filenameOut, int max_len)
  {
    ifstream infile;
    infile.open(filenameIn.c_str() );
    ofstream outfile;
    outfile.open(filenameOut.c_str() );
    string string_in;
    int line_len;
    int offset;
    int i, k = 0;
    int oneword = 1;
    while ( getline(infile, string_in) )
    {
      oneword = 1;
      line_len = string_in.length();
      offset = max_len - line_len;
      for ( i=0; i<line_len; i++ )
      {
        if ( string_in[i] == ' ' )
        {
          oneword = 0;
        }
      }
      if ( !offset )
      {
        outfile << string_in << endl;
      }
      else // string_len < max_len
      {
        if (oneword)
        {
          outfile << string_in;
          while (offset)
          {
            outfile << " ";
            offset--;
          }
          outfile << endl;
        }
        else
        {
          int n = 0;
          while ( offset )
          {
            if ( k > (line_len-1) )
            {
              k = 0;
            }

            if ( string_in[k] == ' ' )
            {
              string_in.insert(k," ");
              k++;
              while ( string_in[k++] == ' ')
              {
              }
              line_len++;
              offset--;
            }
            k++;
          }
          k = 0;
          outfile << string_in << endl;
        }
      }
    }
    infile.close();
    outfile.close();
  }
};

int main( int argc, char* argv[] )
{
  if ( argc != 4 )
  {
    return 0;
  }
  LineTools linetool;
  linetool.justifyLines(argv[1], argv[2], atoi(argv[3]));
  return 0;
}
{% endhighlight %}
		</p>
		<p>
			This is how it can be run.
		</p>
		<p>
{% highlight console %}
; cat filein.txt
abcdefghijklmnopqrstuvwxyz
a ef ijkl op svwxyz
a cd nopqr z

; file.o filein.txt fileout.txt 26
; cat fileout.txt
abcdefghijklmnopqrstuvwxyz
a   ef   ijkl   op  svwxyz
a      cd      nopqr     z

; file.o filein.txt fileout.txt 27
; cat fileout.txt
abcdefghijklmnopqrstuvwxyz
a   ef   ijkl   op   svwxyz
a      cd      nopqr      z
{% endhighlight %}
		</p>

		<p>
			<h4>Remarks</h4>
		</p>
		<p>
			In the future, I should definitely add a method for it to accept from the console either no maximum line length, or a value, so that it can justify either types.
		</p>
		<p>
			A limitation I hate about this algorithm is that it cannot differentiate between monospaced and regular fonts. In fact, it works only for monospaced fonts. I want to see in the future if I can find a way to determine the font and justify accordingly, and somewhat reproduce the line algorithms text editors use.
		</p>
	</div>
</div>